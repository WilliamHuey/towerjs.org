<header class="header subhead" id="overview"><h1>Models</h1>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &#39;firstName&#39;
</code></pre>

<p>All of the examples on this page assume <code>Tower.Model</code> is using the memory datastore <code>Tower.Store.Memory</code>, which doesn&#39;t require a callback in any of its finder/persistence methods.  Makes it easier to read and play around with.</p>
<nav class="subnav"><ul class="nav nav-pills"><li><a href="#attributes">attributes</a></li><li><a href="#callbacks">callbacks</a></li></ul></nav></header><section class="section" id="attributes"><h1><code>Tower.Model.Attributes</code></h1>

<p>Consider a simple class for modeling a user in an application. A user may have a first name, last name, and middle name. We can define these attributes on a user by using the <code>field</code> macro function.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &#39;firstName&#39;, type: &#39;String&#39;
  @field &#39;middleName&#39;, type: &#39;String&#39;
  @field &#39;lastName&#39;, type: &#39;String&#39;
</code></pre>

<p>Below is a list of valid types for fields.</p>

<ul>
<li>Array</li>
<li>[todo] BigDecimal (Stores as a String in the database)</li>
<li>Boolean</li>
<li>Float</li>
<li>Object</li>
<li>Integer</li>
<li>String</li>
<li>Time</li>
<li>Date</li>
<li>DateTime</li>
</ul>

<p>If you decide not to specify the field <code>type</code>, Tower.js will treat it as a JavaScript <code>String</code>.  If you don&#39;t want Tower to try typecasting your value, type it to <code>Object</code>.</p>

<h2>Getting and Setting Field Values</h2>

<p>When a field is defined, Tower provides several different ways of accessing the field.</p>

<pre><code class="coffeescript"># Get the value of the first name field.
user.get(&#39;firstName&#39;)
user.firstName # if get/set support is available and Tower.accessors == true

# Set the value for the first name field.
user.set(&#39;firstName&#39;, &#39;Jean&#39;)
user.firstName = &#39;Jean&#39; # if get/set support is available
</code></pre>

<p>In cases where you want to set multiple field values at once, there are a few different ways of handling this as well.</p>

<pre><code class="coffeescript">User.new(firstName: &#39;Jean-Baptiste&#39;, middleName: &#39;Emmanuel&#39;)

# Get the field values as a hash.
user.getProperties(&#39;firstName&#39;, &#39;middleName&#39;)
#=&gt; { firstName: &#39;Jean-Baptiste&#39;, middleName: &#39;Emmanuel&#39; }

# Set the field values in the record.
user.setProperties(firstName: &#39;Jean-Baptiste&#39;, middleName: &#39;Emmanuel&#39;)
</code></pre>

<p>This is straight from Ember.js.  It wraps all <code>set</code> calls in a single operation.</p>

<h2>Defaults</h2>

<p>You can tell a field in Tower to always have a default value if nothing has been provided. Defaults are either static values or callback functions.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &#39;bloodAlcoholLevel&#39;, type: &#39;Float&#39;, default: 0.40
  @field &#39;lastLogin&#39;, type: &#39;Time&#39;, default: -&gt; 10.minutes.ago
</code></pre>

<p>Be wary that default values that are not defined as functions are evaluated at class load time, so the following 2 definitions are not equivalent. (You probably would prefer the second, which is at record creation time.)</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &#39;dob&#39;, type: &#39;Time&#39;, default: new Date
  @field &#39;dob&#39;, type: &#39;Time&#39;, default: -&gt; new Date
</code></pre>

<p>If you want to set a default with a dependency on the record&#39;s state, <code>this</code> inside a callback evaluates to the record instance.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &#39;joinedAt&#39;, type: &#39;Time&#39;, default: -&gt; if @isNew() then _(2).hours().ago() else new Date
</code></pre>

<h2>Custom Field Serialization</h2>

<p>You can define custom types in Tower and determine how they are serialized and deserialized. You simply need to define the class, include Tower.Model.Attributes.Serializable, and override the serialize and deserialize methods as needed. Deserialization is used to convert from the value that is stored in the database to a value that is used when accessed. Serialization is used to convert the object to a MongoDB friendly value.</p>

<pre><code class="coffeescript">class Profile extends Tower.Model
  @field location, type: &#39;Point&#39;

class App.Point
  @include Tower.Model.Attributes.Serializable

  decode: (object) -&gt;
    [ object[&#39;x&#39;], object[&#39;y&#39;] ]

  encode: (object) -&gt;
    { &#39;x&#39; : object[0], &#39;y&#39; : object[1] }
</code></pre>

<p>Note: This is very similar to how you would define custom fields in <em>Mongoid</em> (MongoDB mapper for Rails).</p>

<h2>Reserved Names</h2>

<p>If you define a field on your record that conflicts with a reserved method name in Tower, the configuration will raise an error. For a list of these you may look at <code>Tower.Model.destructiveFields</code>.</p>
</section><section class="section" id="callbacks"><h1><code>Tower.Model.Callbacks</code></h1>

<p>Tower supports 3 main callbacks:</p>

<ul>
<li><code>before</code></li>
<li><code>around</code></li>
<li><code>after</code></li>
</ul>

<p>The following callbacks are implemented:</p>

<ul>
<li><code>@after   &#39;initialize&#39;</code></li>
<li><code>@before  &#39;validate&#39;</code></li>
<li><code>@after   &#39;validate&#39;</code></li>
<li><code>@before  &#39;create&#39;</code></li>
<li><code>@after   &#39;create&#39;</code></li>
<li><code>@before  &#39;update&#39;</code></li>
<li><code>@after   &#39;update&#39;</code></li>
<li><code>@before  &#39;save&#39;</code></li>
<li><code>@after   &#39;save&#39;</code></li>
<li><code>@before  &#39;destroy&#39;</code></li>
<li><code>@after   &#39;destroy&#39;</code></li>
</ul>

<p>Callbacks are available on any model.</p>

<h2>Define a callback with the callback phase helpers</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &#39;title&#39;, type: &#39;String&#39;
  @field &#39;slug&#39;, type: &#39;String&#39;

  @before &#39;save&#39;, &#39;generateSlug&#39;

  generateSlug:  -&gt;
    @set &#39;slug&#39;, _.parameterize @get(&#39;title&#39;)
</code></pre>

<h2>Define the phase and callback directly</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &#39;title&#39;, type: &#39;String&#39;
  @field &#39;slug&#39;, type: &#39;String&#39;

  @callback &#39;save&#39;, &#39;before&#39;, &#39;generateSlug&#39;

  generateSlug:  -&gt;
    @set &#39;slug&#39;, _.parameterize @get(&#39;title&#39;)
</code></pre>

<h2>Define callbacks with anonymous functions</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &#39;title&#39;, type: &#39;String&#39;
  @field &#39;slug&#39;, type: &#39;String&#39;

  @before &#39;save&#39;, -&gt;
    @set &#39;slug&#39;, _.parameterize @get(&#39;title&#39;)
</code></pre>

<h2>Callbacks can be asynchronous</h2>

<p>If you have a callback that executes asynchronous code, you can add the <code>callback</code> argument to your function, and call it when complete:</p>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &#39;title&#39;, type: &#39;String&#39;
  @field &#39;url&#39;, type: &#39;String&#39;

  @before &#39;save&#39;, &#39;scrapeWebsite&#39;

  scrapeWebsite: (callback) -&gt;
    SomeCrawler.scrapeHTML @get(&#39;url&#39;), (error, html) -&gt;
      callback(error)
</code></pre>

<p>Callbacks are called <em>in series</em>, so if you have several async callbacks, know they will be executed one after another.</p>
</section>