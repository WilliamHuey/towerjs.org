<p>Tower.js Controller Docs.</p>

<h2>Controller <code>request</code> Object (on the Server)</h2>

<p>On the server, the <code>request</code> object is straight from Express. <a href="http://expressjs.com/api.html">Here is the api</a>:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>get raw header value</h1>

request.get('content-type')


<h1>set raw header value</h1>

request.set('content-type', 'application/json; charset=utf-8')


<h1>get content types accepted by client</h1>

request.accepted


<h1>get character encodings accepted by client</h1>

request.acceptedCharsets


<h1>get languages accepted by client</h1>

request.acceptedLanguages


<h1>check if a specific content type is accepted by the requesting client</h1>

request.accepts('html')


<h1>check if charset is accepted by client</h1>

request.acceptsCharset('utf-8')


<h1>check if connected client accepts a specific language</h1>

request.acceptsLanguage()


<h1>get param value (or default if missing)</h1>

request.param('createdAt', _(2).days().ago())


<h1>check if request is of a specific content-type</h1>



<h1>note, technically the <code>content-type</code> header is only valid</h1>



<h1>for PUT and POST, not GET (and not sure about DELETE).</h1>

request.is('html')


<h1>get protocol ("http" or "https")</h1>

request.protocol


<h1>check if request is "https"</h1>

request.secure #=> true|false


<h1>get remote ip address</h1>

request.ip


<h1>get auth credentials from the "Authorization" header</h1>



<h1>"<a href='http://tobi:<a href='mailto:hello@example.com'>hello@example.com</a>'>http://tobi:<a href='mailto:hello@example.com'>hello@example.com</a></a>"</h1>

request.auth #=> { username: 'tobi', password: 'hello' }


<h1>get array of subdomains</h1>

request.subdomains


<h1>get host from "Host" header</h1>

request.host


<h1>Check if the request is fresh, aka</h1>



<h1>- Last-Modified and/or the ETag</h1>



<h1>- still match.</h1>

request.fresh
request.stale #=> !request.fresh


<h1>Check if it's an Ajax request via the 'X-Requested-With' header</h1>

request.xhr


<h1>csrf</h1>

request.session._csrf


<h1>In the middleware:</h1>

app.use express.csrf(value: (request) -> request.body._csrf || request.query._csrf)


<h1><a href='https://developers.google.com/blogger/docs/2.0/json/performance'>https://developers.google.com/blogger/docs/2.0/json/performance</a></h1>

app.use express.compress filter: (request, response) ->
  /json|text|javascript/.test(response.get('content-type'))


<h1>Limit request bodies to the given size in <code>bytes</code>.</h1>

app.use express.limit('5.5mb')
</pre></div>

<p>If the requesting client does not accept one of your encodings or languages, then respond with:</p>

<div class="highlight"><pre lang="">406 "Not Acceptable"
</pre></div>

<h3>Rate Limiting</h3>

<ul>
<li><a href='https://github.com/jhurliman/node-rate-limiter'>https://github.com/jhurliman/node-rate-limiter</a></li>
<li><a href='https://github.com/cloudkick/rate-limiter'>https://github.com/cloudkick/rate-limiter</a></li>
<li><a href='http://chris6f.com/rate-limiting-with-redis'>http://chris6f.com/rate-limiting-with-redis</a></li>
<li><a href='http://www.joshdevins.net/2010/11/22/rate-limiting-http-proxy-in-node-js-and-redis/'>http://www.joshdevins.net/2010/11/22/rate-limiting-http-proxy-in-node-js-and-redis/</a></li>
</ul>

<h2>Controller <code>response</code> Object (on the Server)</h2>

<div class="highlight"><pre lang=" coffeescript">response.status(200)


<h1>Set Link header field with the given <code>links</code>.</h1>

response.links
  next: '<a href='http://api.example.com/users?page=2'>http://api.example.com/users?page=2</a>'
  last: '<a href='http://api.example.com/users?page=5'>http://api.example.com/users?page=5</a>'


<h1>Write to the response body,</h1>



<h1>which is taken care of in the <code>render</code> method already.</h1>

response.send(new Buffer('wahoo'))
response.send(some: 'json')
response.send('<p>some html</p>')
response.send(404, 'Sorry, cant find that')
response.send(404)


<h1>JSON</h1>

response.json(some: 'json')


<h1>JSONP</h1>

response.jsonp(some: 'json')


<h1>Send file for download, options are:</h1>



<h1>- <code>maxAge</code> defaulting to 0</h1>



<h1>- <code>root</code>   root directory for relative filenames</h1>

response.sendfile(path, options)


<h1>Send file as attachment (wraps <code>sendFile</code>, sets "Content-Disposition" header)</h1>

response.download(path, options)


<h1>Set "Content-Type" header through mime-lookup</h1>

response.type('html') # or `response.contentType = 'html'`


<h1>Set response header</h1>

response.set('Content-Type', 'application/json; charset=utf-8')


<h1>Get response header</h1>

response.get('Content-Type')


<h1>Some attachment thing?</h1>

response.attachment(filename)


<h1>Remove cookie</h1>

response.clearCookie(name)


<h1>Save cookie</h1>



<h1>"Remember Me" for 15 minutes</h1>

response.cookie('rememberme', '1', expires: new Date(Date.now() + 900000), httpOnly: true)


<h1>save as above</h1>

response.cookie('rememberme', '1', maxAge: 900000, httpOnly: true)


<h1>redirect</h1>

response.redirect(url)


<h1>render template</h1>

response.render(fn)
</pre></div>

<p><a name="controller-actions" href="#controller-actions"></a></p>

<h2>Controller Actions</h2>

<p>By convention there are 7 RESTful actions for a controller:</p>

<ol>
<li><code>index</code>: Show all resources (<code>GET</code>)</li>
<li><code>new</code>: Build a new resource and render a form (<code>GET</code>)</li>
<li><code>create</code>: Create a new resource (<code>POST</code>)</li>
<li><code>show</code>: Find and show a resource by id (<code>GET</code>)</li>
<li><code>edit</code>: Find a resource by id and render it in a form to edit (<code>GET</code>)</li>
<li><code>update</code>: Update an existing resource (<code>PUT</code>)</li>
<li><code>destroy</code>: Destroy an existing resource (<code>DELETE</code>)</li>
</ol>

<p>If you wanted to manually write out simple controller actions, this is how you might do it:</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  index: ->
    App.Post.all (error, posts) =>
      @render "index", locals: {posts}

  new: ->
    post = new App.Post
    @render "new", locals: {post}

  create: ->
    App.Post.create @params.post, (error, post) =>
      @redirectTo post

  show: ->
    App.Post.find @params.id, (error, post) =>
      @render "show", locals: {post}

  edit: ->
    App.Post.find @params.id, (error, post) =>
      @render "edit", locals: {post}

  update: ->
    App.Post.find @params.id, (error, post) =>
      post.updateAttributes @params.post, (error) =>
        if error
          @render "edit", locals: {post}
        else
          @redirectTo post

  destroy: ->
    App.Post.find @params.id, (error, post) =>
      post.destroy (error) =>
        @redirectTo "index"
</pre></div>

<p><strong>Note</strong>: The above actions won't respond to different content types differently (i.e. for JSON, give me a JSON string, for HTML give me some rendered HTML).  But for some cases that's all you need.</p>

<p>In order for those actions to be accessible, routes must be defined.  Routes to all 7 RESTful actions are generated with the following declaration in <code>config/routes.coffee</code>:</p>

<div class="highlight"><pre lang=" coffeescript">Tower.Route.draw ->
  @resources "posts"
</pre></div>

<p>More on routes in the <a href="/docs/routes">routes section</a>.</p>

<p><a name="custom-actions" href="#custom-actions"></a></p>

<h2>Custom Actions</h2>

<p>Sometimes RESTful actions aren't enough.  To add custom actions, just add a route mapping to the method name for the controller.</p>

<div class="highlight"><pre lang=" coffeescript">Tower.Route.draw ->
  @resources "posts", ->
    @get "dashboard"
</pre></div>

<p><strong>Note</strong>: If you start thinking you need to add a custom action to your controller, I personally recommend asking the community (stack overflow, twitter, github, etc.) if there's a way to fit it into the paradigm.  Several times I thought "this is the one time I need a custom action", but 99% of the time I found a way to fit it in.  This always simplified the system.</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>on the client it has to deserialize <code>page: 10</code> back into a hash from a string.</h1>

Tower.goTo(Tower.urlFor(App.Post, page: 10))


<h1>keeps the params as a hash, and appends them to the hash, a more optimized way to do it.</h1>

Tower.goTo(Tower.urlFor(App.Post), page: 10)
</pre></div>

<p>On the client there is no middleware (at least yet).  It just complicates things.  Should probably get rid of the idea of <code>Tower.HTTP.Request</code> and <code>Tower.HTTP.Response</code>.</p>

<p><a name="single-page-app-flow" href="#single-page-app-flow"></a></p>

<h2>Single Page App Flow</h2>

<p><a name="the-server" href="#the-server"></a></p>

<h3>The Server</h3>

<p>When a user first comes to your site they can come from any url, such as:</p>

<div class="highlight"><pre lang="">/
/posts
/posts/10
</pre></div>

<p>The server tells us the request is coming from a specific user agent and that the desired format is HTML.</p>

<p>But, since your app works through primarily a JSON API, it should return the same base HTML layout no matter what the request is. And ideally, it should return a base set of data <em>in addition</em> to the data for the specific url they're accessing.</p>

<p>Say you're imagining if they go to the root <code>/</code> path, it will bootstrap the current user and the recent posts into the HTML response. That means youre root route, which by default points to <code>application#welcome</code> should bootstrap that data.</p>

<p>Now the thing is, conceptually, you're probably going to build out your single page client app <em>assuming you'll always have that bootstrapped data available</em>. That means we need to always render that bootstrap data when a user first enters your site, no matter what the path.</p>

<p>To do this, all you need is to have your bootstrap data function be run before any action.</p>

<p>This introduces another complexity though. What if you want to render a path, such as <code>/faq</code>, and want it to just to render static HTML like you would in Rails? All you need to do is say <code>@skipBeforeFilter 'boostrap', only: 'faq'</code>. This is assuming you use the default controller action implementation, too. If you write your own controller action, you just respond to <code>html</code> only.</p>

<p><a name="the-client" href="#the-client"></a></p>

<h3>The Client</h3>

<p>Once you get to the client, you have your bootstrap data that's the same for any path, and the data that's specific to the path.</p>

<p>What happens now is the <code>App.stateManager</code> traverses it's states based on the routes, culminating in a call to a controller action on the client. The controller action will, by default, render the Ember view for that action.</p>

<p><a name="controller-callbacks" href="#controller-callbacks"></a></p>

<h2>Controller Callbacks</h2>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends App.ApplicationController
  @beforeAction 'check'
</pre></div>

<p><a name="client-side-controllers" href="#client-side-controllers"></a></p>

<h2>Client-side Controllers</h2>

<p>[todo, just notes so far / partial implementation in <a href="http://github.com/viatropos/tower/tree/development">development</a> branch]</p>

<p><a name="overview" href="#overview"></a></p>

<h2>Overview</h2>

<p>Client-side controllers will, like server-side controllers, have a default implementation that <em>just works</em> for the 7 common actions.</p>

<p><a name="differences-between-client-and-server-controllers" href="#differences-between-client-and-server-controllers"></a></p>

<h2>Differences between client and server controllers</h2>

<ul>
<li>server-side controllers have to respond to different formats (json, html, xml, etc.), client-controllers don't.</li>
<li>client-side controllers can handle DOM events, keyboard events, socket messages, and urls (using history pushstate), server-controllers only handle urls and socket messages.</li>
</ul>

<p><a name="the-index-action" href="#the-index-action"></a></p>

<h2>The <code>index</code> action.</h2>

<p>On the server, the <code>index</code> usually fetches a collection of models matching a set of criteria from the database, and renders them into JSON or HTML.  Pretend our server-side index action looks like this:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>server-side controller</h1>

class App.UsersController extends App.ApplicationController
  index: ->
    App.User.where(createdAt: '>=': _(2).days().ago()).all (error, users) =>
      @render "users/index", locals: {users: users}
</pre></div>

<p>On the client, when using Ember.js, we want to somehow cache that collection that was returned from <code>App.User.where...</code>.</p>

<p>You could do that by refactoring it to a separate method:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>client-side controller</h1>

class App.UsersController extends App.ApplicationController
  users: ->
    @_users ||= App.User.where(createdAt: '>=': _(2).days().ago()).all

  index: ->
    @render "users/index", locals: {users: @users}
</pre></div>

<p>Assuming the above example was on the client, and assuming <code>App.User...all</code> returned a users array, then our <code>index</code> action on the client would always render the initial set of users in our client-side store.  If we added users to the client store, we wouldn't see those updates.  (Granted, you could use the first example server-side controller on the client, and you would get the updated users collection, because you're making the query every time, but that's not what we're focusing on).</p>

<p>This is where you start using Ember.js.  One example is to use computed properties, which allows you to define basically a getter/setter:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>client-side controller</h1>

class App.UsersController extends App.ApplicationController
  users: Ember.computed(->
    App.User.where(createdAt: '>=': _(2).days().ago()).all
  ).cacheable()

  index: ->
    @render "users/index", locals: {users: @get('users')}
</pre></div>

<p>This really doesn't change anything (because Tower's chainable scopes are already <code>Ember.ArrayProxy</code> instances, so they're bindable by default).  Also, this client-side controller is starting to look a lot different than the server-side controller:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>server-side controller</h1>

class App.UsersController extends App.ApplicationController
  index: ->
    App.User.where(createdAt: '>=': _(2).days().ago()).all (error, users) =>
      @render "users/index", locals: {users: users}
</pre></div>

<p>What if you could make them the same?  You can, like this:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>client-side controller</h1>

class App.UsersController extends App.ApplicationController
  # don't even need to define it, just showing you
  users: null

  index: ->
    @getUsers (error, users) =>
      @render "users/index"

  getUsers: (callback) ->
    users = @get('users')
    return callback.call(@, null, users) if users
    App.User.where(createdAt: '>=': _(2).days().ago()).all (error, users) =>
      @set('users', users) # THIS IS KEY
      callback.call(@, error, users)
</pre></div>

<p>You could use that on both the client and the server.</p>

<p>That simple call to <code>@set('users', users)</code> will tell ember to begin watching that collection.  And we only initialize it once - on the server, since every controller is a new instance, this will always be null, but on the client, it will only be null once.</p>

<p>Then, <code>@render 'users/index'</code> will, on the client, create a new <code>Ember.View</code> if one hasn't been instantiated yet, otherwise it will use a new one.  And on the server, it will just render the HTML string.</p>

<p>Look at this a little closer, you can define scopes to use in your Ember/Handlebars templates!</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>client-side controller</h1>

class App.UsersController extends App.ApplicationController
  # don't even need to define it, just showing you
  users:        null
  recentUsers:  null

  index: ->
    if @params.recent == true
      @getRecentUsers (error, users) =>
        @render "users/index"
    else
      @getUsers (error, users) =>
        @render "users/index"

  getRecentUsers: (callback) ->
    users = @get('recentUsers')
    return callback.call(@, null, users) if users
    App.User.where(createdAt: '>=': _(2).days().ago()).all (error, users) =>
      @set('recentUsers', users) # THIS IS KEY
      callback.call(@, error, users)

  getUsers: (callback) ->
    users = @get('users')
    return callback.call(@, null, users) if users
    App.User.all (error, users) =>
      @set('users', users) # THIS IS KEY
      callback.call(@, error, users)
</pre></div>

<div class="highlight"><pre lang=" html">{{#each App.usersController.recentUsers}}
...
{{/each}}
</pre></div>

<p>But because you have the <code>@cursor()</code> object in the controllers, which is passed to the scope, you can just customize that to scope any list of users.</p>

<p>Just so you know, this is all implemented internally, in a very dynamic way, making it so you don't have to write any code in your controllers and you get this by default.</p>

<p>Now the question pops up, what if you want more for your client-side controllers?  No problem, you are totally free to create a controller specific to the client and one specific to the server, or add stuff specific to the client to the main controller, and just never use that code on the server, it's up to you.  So you could do this:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>client-side controller</h1>

class App.UsersController extends App.ApplicationController
  # don't even need to define it, just showing you
  users:        App.User.all
  recentUsers:  App.User.where(createdAt: '>=': _(2).days().ago()).all
</pre></div>

<div class="highlight"><pre lang=" html">{{#each App.usersController.recentUsers}}
...
{{/each}}
</pre></div>

<p>Boom, you set them by default, and they never need to be set again on the client.  Just some ideas.</p>

<p><a name="query-parameter-api" href="#query-parameter-api"></a></p>

<h2>Query Parameter API</h2>

<p>You can define parameters which should be parsed into a <code>Tower.Model.Criteria</code>.  This allows you to build a very robust query api with minimal effort.</p>

<p>Tower uses a set of pseudo-ruby conventions for defining ranges and sets of values to query by.  They are defined with the <code>@param</code> class method on a controller.  Tower looks for the attribute definition on the model class associated with the controller, unless you have specified the <code>type</code> option.</p>

<div class="highlight"><pre lang=" coffeescript">class App.EventsController extends Tower.Controller
  @param "title"
  @param "createdAt"
  @param "memberCount"
  @param "tags", type: "Array"
  @param "coordinates"
  @param "admin", source: "admin.firstName"

  index: ->
    App.Event.where(@criteria()).all (error, events) =>
      @render json: events
</pre></div>

<ul>
<li><code>String</code></li>
<li><code>Date</code></li>
<li><code>Array</code></li>
<li><code>Number</code></li>
<li><code>Order</code></li>
<li><code>Coordinates</code></li>
</ul>

<p><a name="string" href="#string"></a></p>

<h3><code>String</code></h3>

<p><a name="query" href="#query"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">title=Hello+World
title=Hello+-World
title='Hello+World'
</pre></div>

<p><a name="criteria" href="#criteria"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "title" : { "$match" : ["Hello", "World"] } }
{ "title" : { "$match" : ["Hello"], "$notMatch" : ["World"] } }
{ "title" : { "$match" : ["Hello World"] } }
</pre></div>

<p><a name="date" href="#date"></a></p>

<h3><code>Date</code></h3>

<p><a name="query-1" href="#query-1"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">createdAt=12-31-2011
createdAt=12-31-2011..t
createdAt=t..12-31-2011
createdAt=12-21-2011..12-31-2011
createdAt=12-21-2011..12-31-2011,01-04-2012
</pre></div>

<p><a name="criteria-1" href="#criteria-1"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "createdAt" : Date(12-31-2011) }
{ "createdAt" : { "$gte": Date(12-31-2011) } }
{ "createdAt" : { "$lte": Date(12-31-2011) } }
{ "createdAt" : { "$gte": Date(12-21-2011), "$lte": Date(12-31-2011) } }
{ "$or": [ { "createdAt" : { "$gte": Date(12-21-2011), "$lte": Date(12-31-2011) } }, { "createdAt" : Date(01-04-2012) } ] }
</pre></div>

<p><a name="number" href="#number"></a></p>

<h3><code>Number</code></h3>

<p><a name="query-2" href="#query-2"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">likeCount=1
likeCount=1..n
likeCount=n..100
likeCount=1..100
likeCount=1..100,1000
likeCount=-10
likeCount=^10
likeCount=^10,1000
likeCount=^10..1000
likeCount=^-1000
</pre></div>

<p><a name="criteria-2" href="#criteria-2"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "likeCount" : 1 }
{ "likeCount" : { "$gte": 1 } }
{ "likeCount" : { "$lte": 1 } }
{ "likeCount" : { "$gte": 1, "$lte": 100 } }
{ "$or": [{ "likeCount" : { "$gte": 1, "$lte": 100 } }, { "likeCount" : 1000 }] }
{ "likeCount": -10 }
{ "likeCount": { "$neq": -10 } }
{ "likeCount": { "$neq": 10, "$in": [1000] } }
{ "nor": [ { "likeCount" : { "$gte": 10, "$lte": 1000 } } ] }
{ "likeCount": { "$neq": -1000 } }
</pre></div>

<p><a name="array" href="#array"></a></p>

<h3><code>Array</code></h3>

<p><a name="query-3" href="#query-3"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">tags=javascript
tags=^java
tags=ruby,^java
tags=[ruby,javascript]
</pre></div>

<p><a name="criteria-3" href="#criteria-3"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "tags" : { "$in": ["javascript"] } }
{ "tags" : { "$nin": ["java"] } }
{ "tags" : { "$in": ["ruby"], "$nin": ["java"] } }
{ "tags" : { "$all": ["ruby", "javascript"] } }
</pre></div>

<p><a name="coordinates" href="#coordinates"></a></p>

<h3><code>Coordinates</code></h3>

<p><a name="query-4" href="#query-4"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">coordinates=51.509981,-0.074704
coordinates=51.509981,-0.074704,10
</pre></div>

<p><a name="criteria-4" href="#criteria-4"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "coordinates" : { "$near": [51.509981, -0.074704] } }
{ "coordinates" : { "$near": [51.509981, -0.074704] , "$maxDistance" : 10 } }
</pre></div>

<p><a name="order" href="#order"></a></p>

<h3><code>Order</code></h3>

<p><a name="query-5" href="#query-5"></a></p>

<h4>Query</h4>

<div class="highlight"><pre lang=" coffeescript">sort=title
sort=title+
sort=title-
sort=createdAt-,title
sort=createdAt+,title+
</pre></div>

<p><a name="criteria-5" href="#criteria-5"></a></p>

<h4>Criteria</h4>

<div class="highlight"><pre lang=" coffeescript">{ "sort" : [["title", "asc"]] }
{ "sort" : [["title", "asc"]] }
{ "sort" : [["title", "desc"]] }
{ "sort" : [["createdAt", "desc"], ["title", "asc"]] }
{ "sort" : [["createdAt", "asc"], ["title", "asc"]] }
</pre></div>

<p><a name="complete-url-query-examples" href="#complete-url-query-examples"></a></p>

<h3>Complete URL Query Examples</h3>

<div class="highlight"><pre lang=" coffeescript"><a href='http://events.towerjs.org/?createdAt=12-25-2011'>http://events.towerjs.org/?createdAt=12-25-2011</a>
<a href='http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011'>http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011</a>
<a href='http://events.towerjs.org/?tags=javascript,ruby'>http://events.towerjs.org/?tags=javascript,ruby</a>
<a href='http://events.towerjs.org/?memberCount=10..n'>http://events.towerjs.org/?memberCount=10..n</a>
<a href='http://events.towerjs.org/?sort=createdAt-,title+'>http://events.towerjs.org/?sort=createdAt-,title+</a>
<a href='http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby'>http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby</a>
<a href='http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&sort=createdAt-,title+'>http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&sort=createdAt-,title+</a>
<a href='http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&memberCount=10..n&sort=createdAt-,title+'>http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&memberCount=10..n&sort=createdAt-,title+</a>
<a href='http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&memberCount=10..n&coordinates=51.509981,-0.074704,10&sort=createdAt-,title+'>http://events.towerjs.org/?createdAt=12-25-2011..12-31-2011&tags=javascript,ruby&memberCount=10..n&coordinates=51.509981,-0.074704,10&sort=createdAt-,title+</a>
</pre></div>

<p>The last url above would generate the criteria:</p>

<div class="highlight"><pre lang=" coffeescript">{ 
  "coordinates" : { "$near": [51.509981, -0.074704] , "$maxDistance" : 10 },
  "createdAt" : { "$gte": Date(12-21-2011), "$lte": Date(12-31-2011) },
  "memberCount" : { "$gte": 10 },
  "sort" : [["createdAt", "desc"], ["title", "asc"]], 
  "tags" : { "$in": ["ruby", "javascript"] }
}
</pre></div>

<p><a name="todo-or-queries-over-several-attributes" href="#todo-or-queries-over-several-attributes"></a></p>

<h4>(todo) <code>OR</code> Queries Over Several Attributes</h4>

<p>You can do <code>OR</code> searches over several attributes, i.e. "find all posts in the past 2 days OR those tagged with 'javascript'".  Just prepend each <code>OR</code> block with an array index:</p>

<div class="highlight"><pre lang=" coffeescript">

<h1>find all posts between christmas and new years eve, or those tagged with "javascript" and "ruby", then sort by date and title</h1>

[0]createdAt=12-25-2011..12-31-2011&[1]tags=javascript,ruby&sort=createdAt-,title+
createdAt[0]=12-25-2011..12-31-2011&tags[1]=javascript,ruby&sort=createdAt-,title+
</pre></div>

<p><a name="flash-messages" href="#flash-messages"></a></p>

<h2>Flash Messages</h2>

<p>The flash is a way to pass messages to your user that will appear on screen only once, then disappear when they change or refresh the page -- unless they do something to cause the message to be added back to the flash, like repeating the same error. This feature is modeled on a similar feature that appears in both Rails and Express. The code was modeled closely on Express's, but they function more closely to how they function in Rails --the developer can just <em>use</em> them, without needing to add dynamic helpers or create additional templates. </p>

<p><a name="usage" href="#usage"></a></p>

<h3>Usage</h3>

<p>Using the flash is simple, just call @flash from your controller, and pass it one of three types "error", "success", or "info" followed by the message you want it to flash to your user. For instance:</p>

<div class="highlight"><pre lang="coffeescript">class App.UsersController extends App.ApplicationController
  index: ->
    App.User.all (error, @users) =>
      @flash 'info', 'Hello!'
      @flash 'error', 'Danger Will Robinson!'
      @flash 'success', 'You Did It!!!!!'
      @render "index"
</pre></div>

<p>will produce the following:</p>

<p><img src="https://github.com/edubkendo/flashMessages/raw/master/screenshots/flash_messages_demo.png" alt="Three Flash Messages" title="Three Flash Messages" /></p>

<p>(Note the X's in the corner of each flash message. These come from twitter-bootstrap and allow the user to easily dismiss the messages if they don't want to continue looking at them.)</p>

<p><a name="dynamic-usage" href="#dynamic-usage"></a></p>

<h3>Dynamic Usage</h3>

<p>The flash message can also be generated dynamically, by allowing your program to determine when to call the @flash method based on conditional statements.</p>

<p><a name="simple-case" href="#simple-case"></a></p>

<h4>Simple Case</h4>

<p>For instance, in the simple case, let's assume a posts model with a simple validation for presence on the title field:</p>

<div class="highlight"><pre lang="coffeescript">class App.Post extends Tower.Model
  @field "title", type: "String"
  @field "body", type: "String"
  @field "userId", type: "Integer"

  @belongsTo "user"

  @validates 'title', presence: true

  @timestamps()
</pre></div>

<p>Currently, if the user forgets to fill in the title field, the app will simply fail silently. This could be quite frustrating to a user, who doesn't understand why his post refuses to save. We can solve that with a simple addition to the controller. In the "create" action of the posts controller, do this:</p>

<div class="highlight"><pre lang="coffeescript">class App.PostsController extends App.ApplicationController
  create: ->
    App.Post.create @params.post, (error, @post) =>
      if (k for own k, message of @post.errors).length isnt 0
        @flash 'error', message
        @render "new"
      else
        @render "show"
</pre></div>

<p>Now the user gets returned to the form, with what they have filled in so far left intact, and an easy to spot error message letting them know what they need to do to correct it.</p>

<p><img src="https://github.com/edubkendo/flashMessages/raw/master/screenshots/flash_message_with_single_error.png" alt="Flash Messages: Single Error" title="Flash Message with single error" /></p>

<p>Note that we can't just do a simple check on @posts.errors, because of a quirk in Javascript in which </p>

<div class="highlight"><pre lang=" javascript">{} === {} // false
</pre></div>

<p>returns false. This would cause the form to need to be submitted twice each time, <em>regardless of whether there was an error or not.</em></p>

<p><a name="more-complex-message-generation" href="#more-complex-message-generation"></a></p>

<h4>More Complex Message Generation</h4>

<p>What if there is more than one validation on the model. Let's assume a user model like this:</p>

<div class="highlight"><pre lang="coffeescript">class App.User extends Tower.Model
  @field "email", type: "String"
  @field "firstName", type: "String"
  @field "lastName", type: "String"

  @hasMany "posts"

  @validates 'lastName', 'email', presence: true

  @timestamps()
</pre></div>

<p>Still pretty simple, but this time, the validations check that two fields are completed. In our controller we need to set up something like this:</p>

<div class="highlight"><pre lang="coffeescript">class App.UsersController extends App.ApplicationController
  create: ->
    App.User.create @params.user, (error, @user) =>
      if (k for own k of @user.errors).length isnt 0
        console.log @user.errors
        errString = ""
        num = 0
        for key, value of @user.errors
          num++
          errString = "#{errString} #{num}. #{value}"
        @flash 'error', errString
        @render "new"
      else
        @render 'show'
</pre></div>

<p>Now, if the user were to leave both the email and the last name fields blank, they would see something like:</p>

<p><img src="https://github.com/edubkendo/flashMessages/raw/master/screenshots/flash_messages_errors.png" alt="Flash Messages: Multiple Errors" title="Flash Message with two errors" /></p>

<p>While you can add one message to each of the flash types "error", "success", and "info", as well as create as many additional types as you desire (simply add them to the template in app/views/shared/_flash.coffee), any given type can only hold one message at a time, given the current instantiation. So, we need to build up the message we want to pass to it with some simple string concatenation. This allows all of the error messages to be passed to the flash and shown in the browser when the user is returned to his form.</p>

<p>A note about the above, we could have saved a few lines, and had slightly cleaner looking code, by using the line:</p>

<div class="highlight"><pre lang=" coffeescript">errString = "#{errString} <br /> #{value}"
</pre></div>

<p>Which would have placed a new line between each message, instead of numbering them on the same line. (Unfortunately, "\n" won't work here). However, I felt like for the wiki it would be best to use the safest example possible.</p>

<p><a name="about-the-messages" href="#about-the-messages"></a></p>

<h3>About the Messages</h3>

<p>The flash messages are styled with Twitter-Bootstrap, in keeping with the styling of the rest of Towerjs apps. The template for the messages is stored in app/views/shared/_flash.coffee which is rendered from app/views/layouts/application.coffee. Developers are, of course, free to alter the styling or templates, or remove them completely, as suits the needs of their particular projects.</p>

<p><a name="pagination-via-the-controller" href="#pagination-via-the-controller"></a></p>

<h2>Pagination via the Controller</h2>

<p>[todo] Each cursor has the properties <code>currentPage</code>, <code>pageCount</code>, <code>totalCount</code>, <code>hasNextPage</code>, <code>hasPreviousPage</code>, <code>hasNext</code>, <code>hasPrevious</code>.  This is then bound to your current model cursor:</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  all: App.Post.all()

  next: ->
    @get('all').nextPage().find()

  prev: ->
    @get('all').previousPage().find()
</pre></div>

<p>A cursor.find()</p>

<p><a name="rendering" href="#rendering"></a></p>

<h2>Rendering</h2>

<ul>
<li>Templates</li>
<li>JSON</li>
<li>The Rendering Process</li>
</ul>

<p><a name="rendering-templates" href="#rendering-templates"></a></p>

<h3>Rendering Templates</h3>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  index: ->
    @render "index"
</pre></div>

<p><a name="rendering-json" href="#rendering-json"></a></p>

<h3>Rendering JSON</h3>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  show: ->
    App.Post.find @params.id, (error, post) =>
      @render json: post
</pre></div>

<p><a name="the-rendering-process" href="#the-rendering-process"></a></p>

<h3>The Rendering Process</h3>

<p><a name="respond-with" href="#respond-with"></a></p>

<h4><code>respondWith</code></h4>

<div class="highlight"><pre lang=" coffeescript">show: ->
  App.Post.find @params.id, (error, post) =>
    @respondWith post, (format) =>
      format.html => @render "show"
</pre></div>

<p>This will perform <em>content negotiation</em>, i.e. it will figure out what the mime type the browser prefers and run the corresponding responder method (for html, json, csv, etc.).  Those methods then call the <code>render</code> method.</p>

<p><a name="render" href="#render"></a></p>

<h4><code>render</code></h4>

<div class="highlight"><pre lang=" coffeescript">show: ->
  App.Post.find @params.id, (error, post) =>
    @render "show"
</pre></div>

<p>Calling the render method directly forces a specific content type to be rendered.  Here is the method signature:</p>

<div class="highlight"><pre lang=" coffeescript">render json: {hello: "world"}
render "show"                 # render action: "show"
render "posts/show"           # render file: "posts/show"
render -> h1 "Hello World"
render text: "success", status: 200
</pre></div>

<p><a name="normalize-render" href="#normalize-render"></a></p>

<h4><code>_normalizeRender</code></h4>

<p>This converts the render arguments into a normalized options hash.</p>

<p><a name="render-to-body" href="#render-to-body"></a></p>

<h4><code>_renderToBody</code></h4>

<p><a name="render-option" href="#render-option"></a></p>

<h4><code>_renderOption</code></h4>

<p><a name="render-template" href="#render-template"></a></p>

<h4><code>_renderTemplate</code></h4>

<p><a name="requests" href="#requests"></a></p>

<h2>Requests</h2>

<p>On the server Tower uses <code>superagent</code>.</p>

<ul>
<li>Location</li>
<li>Cookies</li>
<li>User Agent</li>
</ul>

<p><a name="url" href="#url"></a></p>

<h2>URL</h2>

<div class="highlight"><pre lang=" coffeescript">
</pre></div>

<p><a name="user-agent" href="#user-agent"></a></p>

<h2>User Agent</h2>

<p><a name="subdomains" href="#subdomains"></a></p>

<h2>Subdomains</h2>

<p><a name="cookies" href="#cookies"></a></p>

<h2>Cookies</h2>

<p><a name="session" href="#session"></a></p>

<h2>Session</h2>

<h1><code>Tower.Controller.Resources</code></h1>

<p>Tower goes by the convention that every controller represents one resource, one model.</p>

<p>A controller doesn't <em>need</em> to follow these conventions, for example with a <code>DashboardController</code> or <code>SearchController</code>.  In those cases, overriding the methods starts you with a clean slate.  However, you'll quickly see how powerful this is.</p>

<p><a name="redirecting" href="#redirecting"></a></p>

<h2>Redirecting</h2>

<p><a name="the-resource" href="#the-resource"></a></p>

<h2>The Resource</h2>

<p>You can customize the variable names and resource type:</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  @resource type: "Article", collection: "articles", resource: "article", key: "data", id: "dataId"
</pre></div>

<p><a name="internals" href="#internals"></a></p>

<h2>Internals</h2>

<p>The default implementation for a <code>Tower.Controller</code> looks like this:</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  index: ->

  new: ->

  create: ->

  show: ->

  edit: ->

  update: ->

  destroy: ->
</pre></div>

<p><a name="pub-sub" href="#pub-sub"></a></p>

<h2>Pub/Sub</h2>

<p>This section describes how to setup pub/sub in your application.</p>

<p><a name="towercontroller-subscriptions" href="#towercontroller-subscriptions"></a></p>

<h2><code>Tower.Controller.subscriptions</code></h2>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends App.ApplicationController
  @subscriptions 'all', 'recent', 'archived'
</pre></div>

<p>You can also use the <code>publish</code> method, which is just an alias to <code>subscriptions</code>:</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends App.ApplicationController
  @publish 'all', 'recent', 'archived'
</pre></div>

<p>The keys passed to <code>subscriptions</code> point to methods in the controller that return a <code>Tower.Model.Cursor</code>.  The <em>cursor</em> is an <code>Ember.ArrayProxy</code> that acts as a collection of models matching specific criteria.</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends App.ApplicationController
  @subscriptions 'all', 'recent', 'archived'

  all: App.Post.all()

  recent: App.Post.recent()

  archived: ->
    App.Post.where(authorId: @currentUser.get('id')).archived()
</pre></div>

<p>You can set the subscription to 1 of 3 things:</p>

<ol>
<li>A <code>Tower.Model.Cursor</code> object, which you'll get from <code>.all()</code> (see <code>Tower.Model.Scope</code> for details).</li>
<li>A <code>Tower.Model.Scope</code> object, which is everything before you call <code>.all()</code>.  This will be converted to a criteria when first called, just makes it so you have to write less code.</li>
<li>A <code>Function</code>.  This allows you to integrate things like the current user <code>id</code> for authentication for example.  However, there will be better ways to grab <code>currentUser.id</code> without using a <code>Function</code> soon.</li>
</ol>

<p><a name="error-handling-in-the-controller" href="#error-handling-in-the-controller"></a></p>

<h2>Error Handling in the Controller</h2>

<p><a name="authentication-in-the-controller" href="#authentication-in-the-controller"></a></p>

<h2>Authentication in the Controller</h2>

<p><a name="authorization-in-the-controller" href="#authorization-in-the-controller"></a></p>

<h2>Authorization in the Controller</h2>

<p><a name="caching-in-the-controller" href="#caching-in-the-controller"></a></p>

<h2>Caching in the Controller</h2>

<p><a name="http-caching" href="#http-caching"></a></p>

<h3>HTTP Caching</h3>

<p><a name="1-expiration-headers" href="#1-expiration-headers"></a></p>

<h4>1. Expiration Headers</h4>

<ul>
<li>Back-end sets Cache-Control: public, max-age: 60</li>
<li>Gets cached in gateway cache an browser cache.</li>
<li>Public says it is good for many clients.</li>
<li>Cached for 60s.</li>
</ul>

<div class="highlight"><pre lang=" coffeescript">show: ->
  @expiresIn 60.seconds, public: true
  # stuff
  @render
</pre></div>

<p><a name="2-validation-conditional-get" href="#2-validation-conditional-get"></a></p>

<h4>2. Validation (Conditional Get)</h4>

<ul>
<li>Back-end adds ETag or Last-modified, e.g. ETag: abcdef012345</li>
<li>Last-modified is redundant, basically there for HTTP 1.0 clients.</li>
<li>On 2nd request, gateway cache realizes it has this page in cache, then sends a GET /foo, Host: foo.com, If-None-Match: abcdef012345 to the back-end.</li>
<li>If back-end returns a 304 Not Modified, gateway cache returns cached version.</li>
</ul>

<div class="highlight"><pre lang=" coffeescript">show: ->
  @foo = Foo.find(@params.id)
  @freshWhen etag: @foo, lastModfied: @foo.get("updatedAt")
</pre></div>

<div class="highlight"><pre lang=" coffeescript">show: ->
  @foo = Foo.find(@params.id)
  if @isStale(etag: @foo, lastModfied: @foo.get("updatedAt"))
    @respondTo ...
</pre></div>

<p><a name="combine-expiration-and-validation" href="#combine-expiration-and-validation"></a></p>

<h4>Combine Expiration and Validation</h4>

<ul>
<li>Back-end sets Cache-control: public, max=age=60 and ETag: abcdef012345</li>
<li>In &lt; 60 seconds, cache-control takes precedence</li>
<li>After 60 seconds, it queries back-end using ETag</li>
<li>Back end can then send back a 304 not modified with a new Cache-control: public, max-age: 60</li>
</ul>

<p><a name="handling-events" href="#handling-events"></a></p>

<h2>Handling Events</h2>

<p>All controller actions are just events.  This means then that controllers handle events:</p>

<ul>
<li>DOM events</li>
<li>Keyboard events</li>
<li>Gesture events</li>
<li>socket messages</li>
<li>url requests</li>
</ul>

<p>Instead of having to create a controller for each type of message, why not just establish some conventions:</p>

<p><strong>Note:</strong> As of the current master branch manual socket manipulation (@on, @emit) are broken / not fully implemented. Work in progress.</p>

<div class="highlight"><pre lang=" coffeescript">class App.PostsController extends Tower.Controller
  # socket.io handler
  @on "create", "syncCreate" # created by default... knows because it's named after an action
  @on "notification", "flashMessage" # knows it's socket because 'notification' isn't an action or dom event keyword
  @on "mousemove", "updateHeatMap", type: 'socket' # if you name a socket event after a keyword then pass the `type: 'socket'` option.

  # dom event handler
  @on "click", "click"
  @on "click .item a", "clickItem"
  # or as an object
  @on "click .itemA a": "clickItemA",
    "click .itemB a": "clickItemB",
    "click .itemC a": "clickItemC"

  @on "change #user-first-name-input", "enable", dependent: "#user-last-name-input"
  @on "change #user-first-name-input", "enable #user-last-name-input" # enable: (selector)
  @on "change #user-first-name-input", "validate"
  @on "change #user-first-name-input", bind: "firstName"
  @bind "change #user-first-name-input", "firstName"
  @on "click #add-user-address", "addAddress"
  @on "click #add-user-address", "add", object: "address"
  @on "click #remove-user-address", "removeAddress"
  # $(window).on('click', '#user-details', "toggleDetails");
  @on "click #user-details", "toggleDetails"

  # show or hide
  toggleShowHide: ->

  show: ->

  hide: ->

  toggleSelectDeselect: ->

  select: ->

  deselect: ->

  toggleAddRemove: ->

  add: ->

  remove: ->

  toggleEnableDisable: ->  
    if _.blank(value)
      @disable()
    else
      @enable()

  # enable or disable
  enable: ->
    $(options.dependent).attr("disabled", false)

  disable: ->
    $(options.dependent).attr("disabled", true)

  validate: (element) ->
    element

  invalidate: ->

  bind: ->

  next: ->

  prev: ->
</pre></div>

<h2>Manual Sockets / Pub/Sub Sockets.</h2>

<p><strong>Note:</strong> This feature is in-progress as is not currently shipped in Tower. Nonetheless this feature should be ready soon.</p>

<p>For typical models, Tower employs a data-synchronization feature that handles real-time change. This is all great and fancy but what if you need more control in your hands? </p>

<p>Pub/Sub sockets are the answer. Both the client and server controllers will have this functionality and the api is indifferent. On either the client or the server you would first subscribe (<code>@on</code>) or listen on a particular message. </p>

<h3>Listen</h3>

<div class="highlight"><pre lang=" coffeescript">@on 'notification'
</pre></div>

<p>The first parameter holds the type of message your listening on. This can be anything you want. <br />The second parameter contains either a string with a method name or an anonymous function. </p>

<div class="highlight"><pre lang=" coffeescript">class App.SomeController extends App.ApplicationController

  @on 'notification', 'someMethodHere'

  someMethodHere: (event) ->
    # Some logic here.

  @on 'notification', (event) ->
    # A shorter syntax.
</pre></div>

<p>Both ways will work the later is just shorter. </p>

<h3>Send</h3>

<p>Sending a socket message is no different and just as simple. </p>

<div class="highlight"><pre lang=" coffeescript">class App.SomeController extends App.ApplicationController

  index: ->
    @emit 'notification', message: 'Hello, World'

</pre></div>

<p>The first parameter is identical to <code>@on</code>, the difference is the next parameters which are simple json objects.</p>

<p><a name="observing-and-binding-to-controllers" href="#observing-and-binding-to-controllers"></a></p>

<h2>Observing and Binding to Controllers</h2>

<p><code>Tower.Controller</code> extends the <code>Ember.Object</code>, which is observable.</p>

<p><a name="resources" href="#resources"></a></p>

<h2>Resources</h2>

<ul>
<li><a href='http://pivotallabs.com/users/spierson/blog/articles/842-railsconf-http-s-best-kept-secret-caching-ryan-tomayko-heroku-'>http://pivotallabs.com/users/spierson/blog/articles/842-railsconf-http-s-best-kept-secret-caching-ryan-tomayko-heroku-</a></li>
</ul>