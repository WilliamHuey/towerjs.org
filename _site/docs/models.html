<header class="header subhead" id="overview"><h1>Models</h1>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;firstName&quot;
</code></pre>
<nav class="subnav"><ul class="nav nav-pills"><li><a href="#attributes">attributes</a></li><li><a href="#callbacks">callbacks</a></li><li><a href="#changes">changes</a></li><li><a href="#finders">finders</a></li><li><a href="#querying">querying</a></li><li><a href="#naming">naming</a></li><li><a href="#persistence">persistence</a></li><li><a href="#validations">validations</a></li></ul></nav></header><section class="section" id="attributes"><h1><code>Tower.Model.Attributes</code></h1>

<p>Consider a simple class for modeling a user in an application. A user may have a first name, last name, and middle name. We can define these attributes on a user by using the fields macro.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;firstName&quot;, type: &quot;String&quot;
  @field &quot;middleName&quot;, type: &quot;String&quot;
  @field &quot;lastName&quot;, type: &quot;String&quot;
</code></pre>

<p>Below is a list of valid types for fields.</p>

<ul>
<li>Array</li>
<li>BigDecimal (Stores as a String in the database)</li>
<li>Boolean</li>
<li>Date</li>
<li>DateTime</li>
<li>Float</li>
<li>Hash</li>
<li>Integer</li>
<li>String</li>
<li>Time</li>
</ul>

<p>If you decide not to specify the field&#39;s <code>type</code>, Tower.js will treat it as a JavaScript <code>Object</code> and will try not typecast it when sending the values to the data store.  This means that by default you can easily store things like arbitrary JavaScript objects in MongoDB without worrying about it.</p>

<h2>Getting and Setting Field Values</h2>

<p>When a field is defined, Tower provides several different ways of accessing the field.</p>

<pre><code class="coffeescript"># Get the value of the first name field.
user.get(&quot;firstName&quot;)
user.firstName # if get/set support is available

# Set the value for the first name field.
user.set(&quot;firstName&quot;, &quot;Jean&quot;)
user.firstName = &quot;Jean&quot; # if get/set support is available
</code></pre>

<p>In cases where you want to set multiple field values at once, there are a few different ways of handling this as well.</p>

<pre><code class="coffeescript"># Get the field values as a hash.
user.attributes

# Set the field values in the document.
User.new(firstName: &quot;Jean-Baptiste&quot;, middleName: &quot;Emmanuel&quot;)
user.attributes = { firstName: &quot;Jean-Baptiste&quot;, middleName: &quot;Emmanuel&quot; }
</code></pre>

<p><strong>Note</strong>: Unlike frameworks such as Spine.js and Backbone.js, changing an attribute&#39;s value does not dispatch an event.  Tower.js does not come stocked with event dispatching, for many reasons (more on this later).  There is a simple module <code>Tower.Model.Events</code> which you can include in the base model which will add event dispatching.  For simple apps, you don&#39;t need event dispatching using the Controller model from Rails that Tower.js implements.  For complex apps that need data-binding, client-side frameworks like Ember.js, Knockout.js, and Angular.js complement Tower.js perfectly and can definitely be used with it.</p>

<h2>Defaults</h2>

<p>You can tell a field in Tower to always have a default value if nothing has been provided. Defaults are either static values or callback functions.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;bloodAlcoholLevel&quot;, type: &quot;Float&quot;, default: 0.40
  @field &quot;lastLogin&quot;, type: &quot;Time&quot;, default: -&gt; 10.minutes.ago
</code></pre>

<p>Be wary that default values that are not defined as functions are evaluated at class load time, so the following 2 definitions are not equivalent. (You probably would prefer the second, which is at document creation time.)</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;dob&quot;, type: &quot;Time&quot;, default: Time.now
  @field &quot;dob&quot;, type: &quot;Time&quot;, default: -&gt; Time.now
</code></pre>

<p>If you want to set a default with a dependency on the document&#39;s state, <code>this</code> inside a callback evaluates to the document instance.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;joinedAt&quot;, type: &quot;Time&quot;, default: -&gt; if @isNew() then 2.hours.ago else Time.now
</code></pre>

<h2>Custom Field Serialization</h2>

<p>You can define custom types in Tower and determine how they are serialized and deserialized. You simply need to define the class, include Tower::Fields::Serializable, and override the serialize and deserialize methods as needed. Deserialization is used to convert from the value that is stored in the database to a value that is used when accessed. Serialization is used to convert the object to a MongoDB friendly value.</p>

<pre><code class="coffeescript">class Profile extends Tower.Model
  @field location, type: &quot;Point&quot;

class Point
  include Tower::Fields::Serializable

  decode: (object) -&gt;
    [ object[&quot;x&quot;], object[&quot;y&quot;] ]

  encode: (object) -&gt;
    { &quot;x&quot; : object[0], &quot;y&quot; : object[1] }
</code></pre>

<h2>Reserved Names</h2>

<p>If you define a field on your document that conflicts with a reserved method name in Tower, the configuration will raise an error. For a list of these you may look at <code>Tower.destructiveFields</code>.</p>
</section><section class="section" id="callbacks"><h1><code>Tower.Model.Callbacks</code></h1>

<p>Tower supports 3 main callbacks:</p>

<ul>
<li><code>before</code></li>
<li><code>around</code></li>
<li><code>after</code></li>
</ul>

<p>The following callbacks are implemented:</p>

<ul>
<li><code>@after   &quot;initialize&quot;</code></li>
<li><code>@before  &quot;validate&quot;</code></li>
<li><code>@after   &quot;validate&quot;</code></li>
<li><code>@before  &quot;create&quot;</code></li>
<li><code>@after   &quot;create&quot;</code></li>
<li><code>@before  &quot;update&quot;</code></li>
<li><code>@after   &quot;update&quot;</code></li>
<li><code>@before  &quot;save&quot;</code></li>
<li><code>@after   &quot;save&quot;</code></li>
<li><code>@before  &quot;destroy&quot;</code></li>
<li><code>@after   &quot;destroy&quot;</code></li>
</ul>

<p>Callbacks are available on any model.</p>

<h2>Define a callback with the callback phase helpers</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &quot;title&quot;, type: &quot;String&quot;
  @field &quot;slug&quot;, type: &quot;String&quot;

  @before &quot;save&quot;, &quot;generateSlug&quot;

  generateSlug:  -&gt;
    @set &quot;slug&quot;, @get(&quot;title&quot;).replace(/[^a-z0-9]+/, &#39;-&#39;).toLowerCase()
</code></pre>

<h2>Define the phase and callback directly</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &quot;title&quot;, type: &quot;String&quot;
  @field &quot;slug&quot;, type: &quot;String&quot;

  @callback &quot;save&quot;, &quot;before&quot;, &quot;generateSlug&quot;

  generateSlug:  -&gt;
    @set &quot;slug&quot;, @get(&quot;title&quot;).replace(/[^a-z0-9]+/, &#39;-&#39;).toLowerCase()
</code></pre>

<h2>Define callbacks with anonymous functions</h2>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &quot;title&quot;, type: &quot;String&quot;
  @field &quot;slug&quot;, type: &quot;String&quot;

  @before &quot;save&quot;, -&gt;
    @set &quot;slug&quot;, @get(&quot;title&quot;).replace(/[^a-z0-9]+/, &#39;-&#39;).toLowerCase()
</code></pre>

<h2>Callbacks can be asynchronous</h2>

<p>If you have a callback that executes asynchronous code, you can add the <code>callback</code> argument to your function, and call it when complete:</p>

<pre><code class="coffeescript">class App.Post extends Tower.Model
  @field &quot;title&quot;, type: &quot;String&quot;
  @field &quot;url&quot;, type: &quot;String&quot;

  @before &quot;save&quot;, &quot;scrapeWebsite&quot;

  scrapeWebsite: (callback) -&gt;
    SomeCrawler.scrapeHTML @get(&quot;url&quot;), (error, html) -&gt;
      callback(error)
</code></pre>
</section><section class="section" id="changes"><h1>Dirty Tracking</h1>

<p>Tower supports tracking of changed or &quot;dirty&quot; fields with an API that mirrors that of Active Model. If a defined field has been modified in a model the model will be marked as dirty and some additional behaviour comes into play.</p>

<h2>Viewing Changes</h2>

<p>There are various ways to view what has been altered on a model. Changes are recorded from the time a document is instantiated, either as a new document or via loading from the database up to the time it is saved. Any persistence operation clears the changes.</p>

<pre><code class="coffeescript">class App.User extends Tower.Model
  @field &quot;name&quot;, type: &quot;String&quot;

user = App.User.first()
user.set &quot;name&quot;, &quot;Alan Garner&quot;

# Check to see if the document has changed.
user.isDirty() #=&gt; true

# Get a hash of the old and changed values for each field.
user.changes #=&gt; { &quot;name&quot; : [ &quot;Alan Parsons&quot;, &quot;Alan Garner&quot; ] }

# Get the changes for a specific field.
user.attributeChange(&quot;name&quot;) #=&gt; [ &quot;Alan Parsons&quot;, &quot;Alan Garner&quot; ]

# Get the previous value for a field.
user.attributeWas(&quot;name&quot;) #=&gt; &quot;Alan Parsons&quot;
</code></pre>

<h2>Resetting Changes</h2>

<p>You can reset changes of a field to it&#39;s previous value by calling the reset method.</p>

<pre><code class="coffeescript">user = App.User.first()

user.set &quot;name&quot;, &quot;Alan Garner&quot;

# Reset the changed name back to the original
user.resetAttribute(&quot;name&quot;)
user.get(&quot;name&quot;) #=&gt; &quot;Alan Parsons&quot;
</code></pre>

<h2>Notes on Persistence</h2>

<p>Tower uses dirty tracking as the core of its persistence operations. It looks at the changes on a document and atomically updates only what has changed unlike other frameworks that write the entire document on each save. If no changes have been made, Tower will not hit the database on a call to Model#save.</p>
</section><section class="section" id="finders"><h1>Finders - <code>Tower.Model.Scopes</code> Part 1</h1>

<p>Here are the methods used to query models in a datastore:</p>

<ul>
<li><code>Model.all</code></li>
<li><code>Model.find</code></li>
<li><code>Model.first</code></li>
<li><code>Model.last</code></li>
<li><code>Model.count</code></li>
<li><code>Model.exists</code></li>
<li><code>Model.batch</code></li>
</ul>

<p>These methods are delegated to a method of the same name a <code>Tower.Model.Scope</code> instance.  By delegating all query and persistence calls to the <code>Tower.Model.Scope</code> object, there&#39;s one place in the Tower.js code to build out a very powerful API for chainable scopes (more on that later).  This means you can do:</p>

<pre><code class="coffeescript">User.all()
</code></pre>

<p>or create a reusable scope:</p>

<pre><code class="coffeescript">User.where(firstName: /^[aA]/).limit(10).all()
</code></pre>

<p>By calling one of the finder methods, the scope&#39;s criteria are compiled into an optimized query and the models are queried.</p>

<h2><code>Model.all</code></h2>

<p>Returns an array of models.  It only takes one argument, the <code>callback</code>.  If you&#39;re using the memory store, it will also return an array of models so you don&#39;t need to pass in a callback.  This makes TDD much easier.  BUT, don&#39;t count on that, as the other stores return sometimes random things.  Use the callback whenever you can.  As usual, the first argument in the callback is an error.</p>

<pre><code class="coffeescript">User.all (error, models) -&gt;
  for model in models
    console.log model.get(&quot;id&quot;)
</code></pre>

<h2><code>Model.find</code></h2>

<p>Provides the ability to find one or many models given a set of ids.  This is a more all-inclusive API than <code>all</code>.</p>

<p>The first way to use this method is for finding a single record given the provided <code>id</code>. If no record is found this will raise an error unless the configuration option is changed.  You can call this method on a scope as well, so you can find all users with a last name of &quot;Black&quot; who have this <code>id</code>.</p>

<pre><code class="coffeescript">User.find(id)
User.find(&quot;4baa56f1230048567300485c&quot;)
User.where(lastName: &quot;Black&quot;).find(id)
</code></pre>

<p>You may also find multiple records given the provided array of ids. If a single record is not found the error will get raised.</p>

<pre><code class="coffeescript">User.find([idOne, idTwo])
User.find([&quot;4baa56f1230048567300485c&quot;,&quot;4baa56f1230048567300485d&quot;])
User.where(lastName: &quot;Black&quot;).find([idOne, idTwo])
</code></pre>

<p>If multiple ids are passed, you will get an array back. If you only pass 1 id, then you get a record back. The complete signature looks like this:</p>

<pre><code class="coffeescript">User.find &quot;4baa56f1230048567300485c&quot;, (error, record) -&gt;
User.find [&quot;4baa56f1230048567300485c&quot;, &quot;4baa56f1230048567300485d&quot;], (error, records) -&gt;
</code></pre>

<h2><code>Model.first</code></h2>

<p>Find the first record in the datastore given the provided criteria. Will return a record or null if nothing is found and defaults to the natural sorting of records in the datastore. You can provide sort criteria as well if you want to dictate the exact record that would be returned first.</p>

<pre><code class="coffeescript">User.first (error, record) -&gt;
</code></pre>

<h2><code>Model.last</code></h2>

<p>Find the last record in the datastore given the provided criteria. Will return a record or null if nothing is found and defaults to to sorting by id in descending order. You may provide sort criteria as well if you want to dictate the exact record that would be returned - Tower will invert the sort criteria you provide.</p>

<pre><code class="coffeescript">User.last (error, record) -&gt;
</code></pre>

<h2><code>Model.count</code></h2>

<p>Get the count of records given the provided criteria.</p>

<pre><code class="coffeescript">User.count (error, count) -&gt;
</code></pre>

<h2><code>Model.exists</code></h2>

<p>Returns true if any records in the datastore exist given the provided criteria and false if there are none.</p>

<pre><code class="coffeescript"># Do any records exist in the datastore for the provided conditions?
User.exists (error, exists) -&gt;
</code></pre>

<h2><code>Model.batch</code> (todo)</h2>

<p>This will grab records from the datastore in chunks, to prevent a memory usage explosion if you have a lot of records.</p>

<pre><code class="coffeescript">User.batch(20).each (user) -&gt;
</code></pre>
</section><section class="section" id="querying"><h1>Querying - <code>Tower.Model.Scopes</code> Part 2</h1>

<p>The following are a list of chainable query methods in Tower.js.  Shown alongside each example are the generated query parameters and options which are passed to the <code>store</code> object.  The stores then convert these normalized criteria into the datastore-specific format.</p>

<p>Please note that criteria are lazy evaluated, and with each chained method it will be cloned and return a new criteria copy.</p>

<h2>Query Methods</h2>

<ul>
<li><code>Model.allIn</code></li>
<li><code>Model.allOf</code></li>
<li><code>Model.alsoIn</code></li>
<li><code>Model.anyIn</code></li>
<li><code>Model.anyOf</code></li>
<li><code>Model.asc</code></li>
<li><code>Model.desc</code></li>
<li><code>Model.distinct</code></li>
<li><code>Model.excludes</code></li>
<li><code>Model.includes</code></li>
<li><code>Model.limit</code></li>
<li><code>Model.near</code></li>
<li><code>Model.notIn</code></li>
<li><code>Model.only</code></li>
<li><code>Model.order</code></li>
<li><code>Model.paginate</code></li>
<li><code>Model.offset</code></li>
<li><code>Model.where</code></li>
<li><code>Model.without</code></li>
</ul>

<h2><code>Model.allIn</code></h2>

<p>Adds a criterion that specifies values that must all match in order to return results.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people with Bond and 007 as aliases.
User.allIn(aliases: [&quot;Bond&quot;, &quot;007&quot;])
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;aliases&quot; : { &quot;$all&quot; : [ &quot;Bond&quot;, &quot;007&quot; ] }}
</code></pre>

<h2><code>Model.allOf</code></h2>

<p>Adds a criterion that specifies expressions that must all match in order to return results.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all crazy old people.
User.allOf(age: {&quot;&gt;=&quot;: 60 }, mentalState: &quot;crazy mofos&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;$and&quot; : [{ &quot;age&quot; : { &quot;$gt&quot; : 60 }}, { &quot;mentalState&quot; : &quot;crazy mofos&quot; }] }
</code></pre>

<h2><code>Model.alsoIn</code></h2>

<p>Adds a criterion that specifies values where any value can be matched in order to return results. This is similar to Criteria#anyIn with the exception here that if if it chained with values for the same field it performs a union of the values where anyIn perform an intersection.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people with either Bond or 007 as aliases.
User.alsoIn(aliases: [ &quot;Bond&quot;, &quot;007&quot; ])
User.anyIn(aliases: [ &quot;Bond&quot; ]).alsoIn(aliases: [ &quot;007&quot; ])
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;aliases&quot; : { &quot;$in&quot; : [ &quot;Bond&quot;, &quot;007&quot; ] }}
</code></pre>

<h2><code>Model.anyIn</code></h2>

<p>Adds a criterion that specifies values where any value can be matched in order to return results. This is similar to Criteria#alsoIn with the exception here that if if it chained with values for the same field it performs an intersection of the values where alsoIn perform a union.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people with either Bond or 007 as aliases.
User.anyIn(aliases: [ &quot;Bond&quot;, &quot;007&quot; ])
User
  .anyIn(aliases: [ &quot;Bond&quot;, &quot;007&quot;, &quot;James&quot; ])
  .anyIn(aliases: [ &quot;Bond&quot;, &quot;007&quot; ])
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;aliases&quot; : { &quot;$in&quot; : [ &quot;Bond&quot;, &quot;007&quot; ] }}
</code></pre>

<h2><code>Model.anyOf</code></h2>

<p>Adds a criterion that specifies a set of expressions that any can match in order to return results. The underlying MongoDB expression is $or.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people with either last name Penn or Teller
User.anyOf({ lastName: &quot;Penn&quot; }, { lastName: &quot;Teller&quot; })
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;lastName&quot; :
  { &quot;$or&quot; :
    [ { &quot;lastName&quot; : &quot;Penn&quot; }, { &quot;lastName&quot; : &quot;Teller&quot; } ]
  }
}
</code></pre>

<h2><code>Model.asc</code></h2>

<p>Adds ascending sort options for the provided fields.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Sort people by first and last name ascending.
User.asc(&quot;firstName&quot;, &quot;lastName&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;sort&quot; :
    {[ [ &quot;firstName&quot;, &quot;asc&quot; ],
      [ &quot;lastName&quot;, &quot;asc&quot; ] ]} }
</code></pre>

<h2><code>Model.desc</code></h2>

<p>Adds descending sort options for the provided fields.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Sort people by first and last name descending.
User.desc(&quot;firstName&quot;, &quot;lastName&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;sort&quot; :
    {[ [ &quot;firstName&quot;, &quot;desc&quot; ],
      [ &quot;lastName&quot;, &quot;desc&quot; ] ]} }
</code></pre>

<h2><code>Model.distinct(name)</code></h2>

<p>Get the distinct values for the provided field.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Get the distinct values for last names
User.distinct(&quot;lastName&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;distinct&quot; : &quot;lastName&quot; }
</code></pre>

<h2><code>Model.excludes</code></h2>

<p>Adds a criterion that specifies a set of expressions that cannot match in order to return results. The underlying MongoDB expression is $ne.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people without either last name Teller and first name Bob.
User.excludes(lastName: &quot;Teller&quot;, firstName: &quot;Bob&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{{ &quot;lastName&quot; : { &quot;$ne&quot; : &quot;Teller&quot; } }, { &quot;firstName&quot; : { &quot;$ne&quot; : &quot;Bob&quot; } }}
</code></pre>

<h2><code>Model.includes</code></h2>

<p>Adds a criterion that specifies a list of relational associations to eager load when executing the query. This is to prevent the n+1 issue when iterating over documents that access their relations during the iteration.</p>

<p>This only works with <code>hasMany</code>, <code>hasOne</code>, and <code>belongsTo</code> relations and only 1 level deep at the current moment. If you try to eager load a many to many an exception will get raised. Many to many is not supported due to the performance actually being slower despite lowering the number of datastore calls.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Eager load the posts and games when retrieving the people.
User.includes(&quot;posts&quot;, &quot;comments&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">peopleIds = people.find({}, { &quot;fields&quot; : { &quot;_id&quot; : 1 }})
posts.find({ &quot;personId&quot; : { &quot;$in&quot; : peopleIds }})
comments.find({ &quot;personId&quot; : { &quot;$in&quot; : peopleIds }})
</code></pre>

<h2><code>Model.limit</code></h2>

<p>Limits the number of returned results by the provided value.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Only return 20 documents.
User.limit(20)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;limit&quot; : 20 }
</code></pre>

<h2><code>Model.near</code></h2>

<p>Adds a criterion to find locations that are near the supplied coordinates. This performs a MongoDB $near selection and requires a 2d index to be on the provided field.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all bars near Berlin
Bar.near(location: [ 52.30, 13.25 ])
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;location&quot; : { &quot;$near&quot; : [ 52.30, 13.25 ] }}
</code></pre>

<h2><code>Model.notIn</code></h2>

<p>Adds a criterion that specifies a set of expressions that cannot match in order to return results. The underlying MongoDB expression is $nin.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people without last names Zorg and Dallas
User.notIn(lastName: [ &quot;Zorg&quot;, &quot;Dallas&quot; ])
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{{ &quot;lastName&quot; : { &quot;$nin&quot; : [ &quot;Zorg&quot;, &quot;Dallas&quot; ] } }}
</code></pre>

<h2><code>Model.only</code></h2>

<p>Limits the fields returned from the datastore to those supplied to the method. Extremely useful for list views where the entire documents are not needed. Cannot be used in conjunction with <code>#without</code>.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Return only the first and last names of each person.
User.only(&quot;firstName&quot;, &quot;lastName&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">options: { &quot;fields&quot; : { &quot;firstName&quot; : 1, &quot;lastName&quot; : 1 }}
</code></pre>

<h2><code>Model.order</code></h2>

<p>Sorts the results given the arguments that must match the MongoDB driver sorting syntax (key/value pairs of field and direction).</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Provide the sorting options.
User.order(&quot;firstName&quot;, &quot;asc&quot;).order(&quot;lastName&quot;, &quot;desc&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;sort&quot; :
    {[ [ &quot;firstName&quot;, &quot;asc&quot; ],
      [ &quot;lastName&quot;, &quot;desc&quot; ] ]} }
</code></pre>

<h2><code>Model.skip</code></h2>

<p>Skips the number of the results given the provided value, similar to a SQL &quot;offset&quot;.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Skip 20 documents.
User.skip(20)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;skip&quot; : 20 }
</code></pre>

<h2><code>Model.where</code></h2>

<p>Adds a criterion that must match in order to return results. If provided a string it interperets it as a javascript function and converts it to the proper $where clause. Tower also provides convenience h4s on Symbol to make advanced queries simpler to write.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Match all people with first name Emmanuel
User.where(firstName: &quot;Emmanuel&quot;)

# Match all people who live in Berlin, where address is embedded.
User.where(&quot;addresses.city&quot;: &quot;Berlin&quot;)

# Same as above but with a hash.
User.where(addresses: city: &quot;Berlin&quot;)

# Match all people who live at an address in Berlin or
# Munich where address is embedded.
User.where(&quot;addresses.city&quot;: {&quot;$in&quot;: [&quot;Berlin&quot;, &quot;Munich&quot;]})

# Example complex queries
User.where(age: &quot;&gt;&quot;: 21)
User.where(age: $gt: 21)
User.where(age: &quot;&gt;=&quot;: 21)
User.where(age: $gte: 21)
User.where(title: $in: [&quot;Sir&quot;, &quot;Madam&quot;])
User.where(age: &quot;&lt;&quot;: 55)
User.where(age: $lt: 55)
User.where(age: &quot;&lt;=&quot;: 55)
User.where(age: $lte: 55)
User.where(title: $ne: &quot;Mr&quot;)
User.where(title: $nin: [&quot;Esquire&quot;])
User.where(age: &quot;&gt;=&quot;: 18, &quot;&lt;=&quot;: 55)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript"># Match all people with first name Emmanuel
{ &quot;firstName&quot; : &quot;Emmanuel&quot; }

# Match all people who live in Berlin, where address is embedded.
{ &quot;addresses.city&quot; : &quot;Berlin&quot; }

# Example queries using symbol h4s to perform more complex criteria.
{ &quot;age&quot; : { &quot;$gt&quot; : 18 }}
{ &quot;age&quot; : { &quot;$gt&quot; : 18 }}
{ &quot;age&quot; : { &quot;$gte&quot; : 18 }}
{ &quot;age&quot; : { &quot;$gte&quot; : 18 }}
{ &quot;title&quot; : { &quot;$in&quot; : [ &quot;Sir&quot;, &quot;Madam&quot; ] }}
{ &quot;age&quot; : { &quot;$lt&quot; : 55 }}
{ &quot;age&quot; : { &quot;$lt&quot; : 55 }}
{ &quot;age&quot; : { &quot;$lte&quot; : 55 }}
{ &quot;age&quot; : { &quot;$lte&quot; : 55 }}
{ &quot;title&quot; : { &quot;$ne&quot; : &quot;Mr&quot; }}
{ &quot;title&quot; : { &quot;$nin&quot; : [ &quot;Esquire&quot; ] }}
{ &quot;age&quot; : { &quot;$gte&quot; : 18, &quot;$lte&quot; : 55 }}
</code></pre>

<h2><code>Model.without</code></h2>

<p>Limits the fields returned from the datastore to those NOT supplied to the method. Extremely useful for list views where the entire documents are not needed. Cannot be used in conjunction with <code>#only</code>.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Return all fields except first name and last name
User.without(&quot;firstName&quot;, &quot;lastName&quot;)
</code></pre>

<h3>Criteria</h3>

<pre><code class="coffeescript">{ &quot;fields&quot; : { &quot;firstName&quot; : 0, &quot;lastName&quot; : 0 }}
</code></pre>
</section><section class="section" id="naming"><pre><code class="coffeescript">toParam: &quot;blog-post&quot;
toKey: &quot;blogPost&quot;
toUrl: &quot;/sites/10/blog-posts&quot;
metadata =
  parameterCase:        &quot;blog-post&quot;
  parameterCasePlural:  &quot;blog-posts&quot;
  camelCase:            &quot;blogPost&quot;
  camelCasePlural:      &quot;blogPosts&quot;
  typeCase:             &quot;BlogPost&quot;
  typeCasePlural:       &quot;BlogPosts&quot;
</code></pre>
</section><section class="section" id="persistence"><h1><code>Tower.Model.Persistence</code></h1>

<p>Tower&#39;s standard persistence methods come in the form of common methods you would find in other mapping frameworks.</p>

<ul>
<li><code>Model.create</code></li>
<li><code>Model.delete</code></li>
<li><code>Model.destroy</code></li>
<li><code>Model#save</code></li>
<li><code>Model#updateAttributes</code></li>
<li><code>Model#updateAttribute</code></li>
<li><code>Model#destroy</code></li>
</ul>

<h2><code>Model.create</code></h2>

<p>Inserts a new document into the database given the provided attributes. This will run validations and will return the document whether it was persisted or not. You can check Model#persisted? to see if it was successful.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Insert a new German poet to the db.
Person.create(firstName: &quot;Heinrich&quot;, lastName: &quot;Heine&quot;)
# This can also take a block.
Person.create firstName: &quot;Heinrich&quot;, (record) -&gt;
  doc.lastName = &quot;Heine&quot;
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript">store.create { &quot;firstName&quot; : &quot;Heinrich&quot;, &quot;lastName&quot; : &quot;Heine&quot; }
</code></pre>

<h2><code>Model#save</code></h2>

<p>Saves the document to the database. If the document is new then the entire document will be inserted. If the document is already saved then only changes to the document will the persisted. This runs validations by default, however they can be switched off by providing an option to the method. Returns true if validation passed and false if not.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Insert a new German poet to the db.
person = Person.new(firstName: &quot;Heinrich&quot;, lastName: &quot;Heine&quot;)
person.save()

# Save without running validations.
person.save(validate: false)

# Save an existing document&#39;s changed fields.
person.firstName = &quot;Christian Johan&quot;
person.save()
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript"># Insert command for the new document.
collections[&quot;people&quot;].insert({
  &quot;_id&quot; : ..., &quot;firstName&quot; : &quot;Heinrich&quot;, &quot;lastName&quot; : &quot;Heine&quot;
})

# Update command for the changed document.
collections[&quot;people&quot;].update({
  { &quot;_id&quot; : ... },
  { &quot;$set&quot; : { &quot;firstName&quot; : &quot;Christian Johan&quot; } }
})
</code></pre>

<h2><code>Model#updateAttributes</code></h2>

<p>Modifies the provided attributes to new values and persists them in a single call. This runs validations and will return true if they passed, false if not.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Update the provided attributes.
person.updateAttributes(firstName: &quot;Jean&quot;, lastName: &quot;Zorg&quot;)
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript"># Update command for the changed document.
collections[&quot;people&quot;].update({
  { &quot;_id&quot; : ... },
  { &quot;$set&quot; : { &quot;firstName&quot; : &quot;Jean&quot;, &quot;lastName&quot; : &quot;Zorg&quot; } }
})
</code></pre>

<h2><code>Model#updateAttribute</code></h2>

<p>Updates a single attribute in the database without going through the normal validation procedure, but does fire callbacks. Returns true if save was successful, false if not.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Update the provided attribute.
person.updateAttribute(:firstName, &quot;Jean&quot;)
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript"># Update command for the changed document.
collections[&quot;people&quot;].update({
  { &quot;_id&quot; : ... },
  { &quot;$set&quot; : { &quot;firstName&quot; : &quot;Jean&quot; } }
})
</code></pre>

<h2><code>Model#delete</code></h2>

<p>Deletes the document from the database without running callbacks.</p>

<h3>Model</h3>

<pre><code class="coffeescript">person.delete()
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript">collections[&quot;people&quot;].remove(&quot;_id&quot; : ... )
</code></pre>

<h2><code>Model#destroy</code></h2>

<p>Deletes the document from the database while running destroy callbacks.</p>

<h3>Model</h3>

<pre><code class="coffeescript">person.destroy()
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript">collections[&quot;people&quot;].remove(&quot;_id&quot; : ... )
</code></pre>

<h2><code>Model.delete</code></h2>

<p>Deletes all matching documents in the database given the supplied conditions. See the criteria section on deletion for preferred ways to perform these actions. This does not run any callbacks on the matching documents.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Delete all the documents from the collection.
Person.delete()

# Delete all matching documents.
Person.where(firstName: &quot;Heinrich&quot;).delete()
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript"># Delete all command.
collections[&quot;people&quot;].remove

# Delete all matching command.
collections[&quot;people&quot;].remove(&quot;firstName&quot; : &quot;Heinrich&quot;)
</code></pre>

<h2><code>Model.destroy</code></h2>

<p>Deletes all matching documents in the database given the supplied conditions. See the criteria section on deletion for preferred ways to perform these actions. This runs destroy callbacks on all matching documents.</p>

<h3>Model</h3>

<pre><code class="coffeescript"># Destroy all the documents from the collection.
Person.destroy()

# Destroy all matching documents.
Person.where(firstName: &quot;Heinrich&quot;).destroy()
</code></pre>

<h3>Store</h3>

<pre><code class="coffeescript"># Destroy all command.
collections[&quot;people&quot;].remove

# Destroy all matching command.
collections[&quot;people&quot;].remove(&quot;firstName&quot; : &quot;Heinrich&quot;)
</code></pre>

<h2><code>Model.update</code></h2>

<pre><code class="coffeescript">User.update 1, 2, 3, name: &quot;John&quot;, (error, records)
User.update 1, 2, 3, name: &quot;John&quot;, (error)
User.update [1, 2, 3], name: &quot;John&quot;, (error, records)
User.update [1, 2, 3], name: &quot;John&quot;, (error)
User.update name: &quot;John&quot;, (error, records)
User.update name: &quot;John&quot;, (error)
User.update 1, 2, 3, {name: &quot;John&quot;}, {instantiate: false, validate: false}, (error)
User.update {name: &quot;John&quot;}, {instantiate: false, validate: false}, (error)
</code></pre>

<h2>Other Examples</h2>

<pre><code class="coffeescript"># Model.create
User.create(firstName: &quot;Lance&quot;)
User.where(firstName: &quot;Lance&quot;).create()
User.where(firstName: &quot;Lance&quot;).create([{lastName: &quot;Pollard&quot;}, {lastName: &quot;Smith&quot;}])
User.where(firstName: &quot;Lance&quot;).create(new User(lastName: &quot;Pollard&quot;))

# Model.update
User.where(firstName: &quot;Lance&quot;).update(1, 2, 3)
User.update(User.first(), User.last(), firstName: &quot;Lance&quot;)
User.update([User.first(), User.last()], firstName: &quot;Lance&quot;)
User.update([1, 2], firstName: &quot;Lance&quot;)
</code></pre>
</section><section class="section" id="validations"><h1>Validations</h1>

<h2>The Errors Object</h2>

<h2>Validation Helpers</h2>

<p>Tower offers many pre-defined validation helpers that you can use directly inside your model class definitions. These helpers provide common validation rules. Every time a validation fails, an error message is added to the object&#39;s errors collection, and this message is associated with the field being validated.</p>

<p>Each helper accepts an arbitrary number of attribute names, so with a single line of code you can add the same kind of validation to several attributes.</p>

<p>All of them accept the :on and :message options, which define when the validation should be run and what message should be added to the errors collection if it fails, respectively. The :on option takes one of the values :save (the default), :create or :update. There is a default error message for each one of the validation helpers. These messages are used when the :message option isn&#39;t specified. Let&#39;s take a look at each one of the available helpers.</p>

<h3>Acceptance</h3>

<p>Validates that a checkbox on the user interface was checked when a form was submitted. This is typically used when the user needs to agree to your application&#39;s terms of service, confirm reading some text, or any similar concept. This validation is very specific to web applications and this &#39;acceptance&#39; does not need to be recorded anywhere in your database (if you don&#39;t have a field for it, the helper will just create a virtual attribute).</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;termsOfService&quot;, acceptance: true
</code></pre>

<p>The default error message for this helper is &quot;must be accepted&quot;.</p>

<p>It can receive an :accept option, which determines the value that will be considered acceptance. It defaults to &quot;1&quot; and can be easily changed.</p>

<pre><code class="coffeescript">class User extends Tower.Model
  validates &quot;termsOfService&quot;, acceptance: { accept: &#39;yes&#39; }
</code></pre>

<h3>Associated</h3>

<p>You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, valid? will be called upon each one of the associated objects.</p>

<pre><code class="coffeescript">class Library extends Tower.Model
  @hasMany &quot;books&quot;
  @validates associated: &quot;books&quot;
</code></pre>

<p>This validation will work with all of the association types.</p>

<p>Don&#39;t use validatesAssociated on both ends of your associations. They would call each other in an infinite loop.</p>

<p>The default error message for validatesAssociated is &quot;is invalid&quot;. Note that each associated object will contain its own errors collection; errors do not bubble up to the calling model.</p>

<h3>Confirmation</h3>

<p>You should use this helper when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with &quot;_confirmation&quot; appended.</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;email&quot;, confirmation: true
</code></pre>

<p>In your view template you could use something like</p>

<p>&lt;%= textField :person, :email %&gt;
&lt;%= textField :person, :emailConfirmation %&gt;</p>

<p>This check is performed only if emailConfirmation is not nil. To require confirmation, make sure to add a presence check for the confirmation attribute (we&#39;ll take a look at presence later on this guide):</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;email&quot;, :confirmation: true
  @validates &quot;emailConfirmation&quot;, :presence: true
</code></pre>

<p>The default error message for this helper is &quot;doesn&#39;t match confirmation&quot;.</p>

<h3>Exclusion</h3>

<p>This helper validates that the attributes&#39; values are not included in a given set. In fact, this set can be any enumerable object.</p>

<pre><code class="coffeescript">class Account extends Tower.Model
  @validates &quot;subdomain&quot;, exclusion: { in: [&quot;www&quot;, &quot;us&quot;, &quot;ca&quot;, &quot;jp&quot;], message: &quot;Subdomain %{value} is reserved.&quot; }
</code></pre>

<p>The exclusion helper has an option :in that receives the set of values that will not be accepted for the validated attributes. The :in option has an alias called :within that you can use for the same purpose, if you&#39;d like to. This example uses the :message option to show how you can include the attribute&#39;s value.</p>

<p>The default error message is &quot;is reserved&quot;.</p>

<h3>Format</h3>

<p>This helper validates the attributes&#39; values by testing whether they match a given regular expression, which is specified using the :with option.</p>

<pre><code class="coffeescript">class Product extends Tower.Model
  @validates &quot;legacyCode&quot;, format: { with: /\A[a-zA-Z]+\z/, message: &quot;Only letters allowed&quot; }
</code></pre>

<p>The default error message is &quot;is invalid&quot;.</p>

<h3>Inclusion</h3>

<p>This helper validates that the attributes&#39; values are included in a given set. In fact, this set can be any enumerable object.</p>

<pre><code class="coffeescript">class Coffee extends Tower.Model
  @validates &quot;size&quot;, inclusion: { in: [&quot;small&quot;, &quot;medium&quot;, &quot;large&quot;], message: &quot;%{value} is not a valid size&quot; }
</code></pre>

<p>The inclusion helper has an option :in that receives the set of values that will be accepted. The :in option has an alias called :within that you can use for the same purpose, if you&#39;d like to. The previous example uses the :message option to show how you can include the attribute&#39;s value.</p>

<p>The default error message for this helper is &quot;is not included in the list&quot;.</p>

<h3>Length</h3>

<p>This helper validates the length of the attributes&#39; values. It provides a variety of options, so you can specify length constraints in different ways:</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;name&quot;, length: { minimum: 2 }
  @validates &quot;bio&quot;, length: { maximum: 500 }
  @validates &quot;password&quot;, length: { in: 6..20 }
  @validates &quot;registrationNumber&quot;, length: 6
</code></pre>

<p>The possible length constraint options are:</p>

<p>:minimum – The attribute cannot have less than the specified length.
:maximum – The attribute cannot have more than the specified length.
:in (or :within) – The attribute length must be included in a given interval. The value for this option must be a range.
:is – The attribute length must be equal to the given value.
The default error messages depend on the type of length validation being performed. You can personalize these messages using the :wrongLength, :tooLong, and :tooShort options and %{count} as a placeholder for the number corresponding to the length constraint being used. You can still use the :message option to specify an error message.</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;bio&quot;, length: { :maximum: 1000, tooLong: &quot;%{count} characters is the maximum allowed&quot; }
</code></pre>

<p>This helper counts characters by default, but you can split the value in a different way using the :tokenizer option:</p>

<pre><code class="coffeescript">class Essay extends Tower.Model
  @validates &quot;content&quot;, length:
    minimum:   300,
    maximum:   400,
    tokenizer: lambda { |str| str.scan(/\w+/) },
    tooShort:  &quot;must have at least %{count} words&quot;,
    tooLong:   &quot;must have at most %{count} words&quot;
</code></pre>

<p>Note that the default error messages are plural (e.g., &quot;is too short (minimum is %{count} characters)&quot;). For this reason, when :minimum is 1 you should provide a personalized message or use validatesPresenceOf instead. When :in or :within have a lower limit of 1, you should either provide a personalized message or call presence prior to length.</p>

<p>The size helper is an alias for length.</p>

<h3>Numericality</h3>

<p>This helper validates that your attributes have only numeric values. By default, it will match an optional sign followed by an integral or floating point number. To specify that only integral numbers are allowed set :onlyInteger to true.</p>

<p>If you set :onlyInteger to true, then it will use the</p>

<pre><code class="coffeescript">/\A[+-]?\d+\Z/
</code></pre>

<p>regular expression to validate the attribute&#39;s value. Otherwise, it will try to convert the value to a number using Float.</p>

<p>Note that the regular expression above allows a trailing newline character.</p>

<pre><code class="coffeescript">class Player extends Tower.Model
  @validates &quot;points&quot;, numericality: true
  @validates &quot;gamesPlayed&quot;, numericality: { onlyInteger: true }
</code></pre>

<p>Besides <code>onlyInteger</code>, this helper also accepts the following options to add constraints to acceptable values:</p>

<p>:greaterThan – Specifies the value must be greater than the supplied value. The default error message for this option is &quot;must be greater than %{count}&quot;.
:greaterThanOrEqualTo – Specifies the value must be greater than or equal to the supplied value. The default error message for this option is &quot;must be greater than or equal to %{count}&quot;.
:equalTo – Specifies the value must be equal to the supplied value. The default error message for this option is &quot;must be equal to %{count}&quot;.
:lessThan – Specifies the value must be less than the supplied value. The default error message for this option is &quot;must be less than %{count}&quot;.
:lessThanOrEqualTo – Specifies the value must be less than or equal the supplied value. The default error message for this option is &quot;must be less than or equal to %{count}&quot;.
:odd – Specifies the value must be an odd number if set to true. The default error message for this option is &quot;must be odd&quot;.
:even – Specifies the value must be an even number if set to true. The default error message for this option is &quot;must be even&quot;.
The default error message is &quot;is not a number&quot;.</p>

<h3>Presence</h3>

<p>This helper validates that the specified attributes are not empty. It uses the blank? method to check if the value is either nil or a blank string, that is, a string that is either empty or consists of whitespace.</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;name&quot;, &quot;login&quot;, &quot;email&quot;, presence: true
</code></pre>

<p>If you want to be sure that an association is present, you&#39;ll need to test whether the foreign key used to map the association is present, and not the associated object itself.</p>

<pre><code class="coffeescript">class LineItem extends Tower.Model
  @belongsTo &quot;order&quot;
  @validates &quot;orderId&quot;, presence: true
</code></pre>

<p>Since false.blank? is true, if you want to validate the presence of a boolean field you should use validates :fieldName, :inclusion: { :in: [true, false] }.</p>

<p>The default error message is &quot;can&#39;t be empty&quot;.</p>

<h3>Uniqueness</h3>

<p>This helper validates that the attribute&#39;s value is unique right before the object gets saved. It does not create a uniqueness constraint in the database, so it may happen that two different database connections create two records with the same value for a column that you intend to be unique. To avoid that, you must create a unique index in your database.</p>

<pre><code class="coffeescript">class Account extends Tower.Model
  @validates &quot;email&quot;, uniqueness: true
</code></pre>

<p>The validation happens by performing an SQL query into the model&#39;s table, searching for an existing record with the same value in that attribute.</p>

<p>There is a :scope option that you can use to specify other attributes that are used to limit the uniqueness check:</p>

<pre><code class="coffeescript">class Holiday extends Tower.Model
  validates &quot;name&quot;, uniqueness: { scope: &quot;year&quot;, message: &quot;should happen once per year&quot; }
</code></pre>

<p>There is also a :caseSensitive option that you can use to define whether the uniqueness constraint will be case sensitive or not. This option defaults to true.</p>

<pre><code class="coffeescript">class User extends Tower.Model
  @validates &quot;name&quot;, uniqueness: { caseSensitive: false }
</code></pre>

<p>Note that some databases are configured to perform case-insensitive searches anyway.</p>

<p>The default error message is &quot;has already been taken&quot;.</p>
</section>